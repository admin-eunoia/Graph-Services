# excel_live_writer.py
"""
Escritura en Excel EN VIVO usando Microsoft Graph API.
Lee toda la configuraciÃ³n desde la base de datos automÃ¡ticamente.
"""
from typing import Dict, Any, List, Optional, Tuple
from Services.graph_services import GraphServices, _col_index_to_letters
from sqlalchemy.orm import Session
from Postgress.connection import SessionLocal
from Postgress.Tables import (
    TenantCredentials,
    StorageTargets,
    Templates,
    ExcelFiles,
    ExcelSections,
    ExcelFields
)
from Auth.Microsoft_Graph_Auth import MicrosoftGraphAuthenticator


class ExcelLiveWriter:
    """Wrapper para operaciones de Excel usando Graph API con configuraciÃ³n desde DB."""
    
    def __init__(self, client_key: str, correlation_id: str = None):
        """
        Inicializa el writer con las credenciales del cliente.
        
        Args:
            client_key: Clave del cliente en tenant_credentials
            correlation_id: ID opcional para tracking
        """
        self.client_key = client_key
        self.correlation_id = correlation_id
        self.db = SessionLocal()
        self.client = self._init_graph_client()
    
    def _init_graph_client(self) -> GraphServices:
        """Inicializa el cliente de Graph API usando credenciales de DB."""
        creds = self.db.query(TenantCredentials).filter_by(
            client_key=self.client_key,
            enabled=True
        ).first()
        
        if not creds:
            raise ValueError(f"Cliente '{self.client_key}' no encontrado o deshabilitado")
        
        auth = MicrosoftGraphAuthenticator(
            creds.tenant_id,
            creds.app_client_id,
            creds.app_client_secret
        )
        token = auth.get_access_token()
        return GraphServices(access_token=token, correlation_id=self.correlation_id)
    
    def close(self):
        """Cierra la sesiÃ³n de base de datos."""
        if self.db:
            self.db.close()
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
    
    def _get_file_context(self, file_key: str, section_key: str = None):
        """
        Obtiene contexto completo de archivo y secciÃ³n desde DB.
        
        Returns:
            Tupla con (excel_file, section, fields, storage, file_path, drive_id, target_user_id)
        """
        excel_file = self.db.query(ExcelFiles).filter_by(
            client_key=self.client_key,
            file_key=file_key,
            is_active=True
        ).first()
        
        if not excel_file:
            raise ValueError(f"Archivo '{file_key}' no encontrado")
        
        section = None
        fields = None
        if section_key:
            section = self.db.query(ExcelSections).filter_by(
                client_key=self.client_key,
                template_id=excel_file.template_id,
                section_key=section_key,
                is_active=True
            ).first()
            
            if not section:
                raise ValueError(f"SecciÃ³n '{section_key}' no encontrada")
            
            fields = self.db.query(ExcelFields).filter_by(
                section_id=section.id,
                is_active=True
            ).all()
        
        storage = self.db.query(StorageTargets).filter_by(
            id=excel_file.storage_target_id
        ).first()
        
        if not storage:
            raise ValueError("Storage no encontrado")
        
        file_path = f"{excel_file.file_folder_path}/{excel_file.file_name}".replace("//", "/")
        
        drive_id = None
        target_user_id = None
        if storage.location_type.value.upper() == "DRIVE":
            drive_id = storage.location_identifier
        else:
            target_user_id = storage.location_identifier
        
        return excel_file, section, fields, storage, file_path, drive_id, target_user_id
    
    def buscar_marcador(self, file_key: str, section_key: str) -> Tuple[Optional[int], Optional[int]]:
        """
        Busca un marcador en el Excel.
        
        Args:
            file_key: Clave del archivo
            section_key: Clave de la secciÃ³n
        
        Returns:
            (fila, columna) donde se encontrÃ³ el marcador, o (None, None)
        """
        _, section, _, _, file_path, drive_id, target_user_id = self._get_file_context(file_key, section_key)
        
        marker = section.marker_text
        sheet_name = section.sheet_namename
        
        print(f"ğŸ” Buscando '{marker}'...")
        
        item_id, _ = self.client._resolve_item_id(file_path, target_user_id=target_user_id, drive_id=drive_id)
        sheets, _ = self.client._resolve_worksheets(item_id=item_id, target_user_id=target_user_id, drive_id=drive_id)
    
    if not sheets:
        raise ValueError("No se encontraron hojas en el Excel")
    
    # Seleccionar hoja
    if sheet_name:
        sheet = next((s for s in sheets if s.get("name") == sheet_name), None)
        if not sheet:
            raise ValueError(f"Hoja '{sheet_name}' no encontrada")
    else:
        sheet = sheets[0]
    
    ws_id = sheet["id"]
    
    # Obtener rango usado
    if drive_id:
        base = f"{client.graph_url}/drives/{drive_id}/items/{item_id}"
    else:
        base = f"{client.graph_url}/users/{target_user_id}/drive/items/{item_id}"
    
    url = f"{base}/workbook/worksheets/{ws_id}/usedRange"
        resp, _ = self.client._request_with_retry("GET", url, expected=(200,), headers=self.client._headers())
        
        data = resp.json()
        values = data.get("values", [])
        row_offset = data.get("rowIndex", 0)
        col_offset = data.get("columnIndex", 0)
        
        for row_idx, row in enumerate(values):
            for col_idx, cell_value in enumerate(row):
                if cell_value and marker in str(cell_value):
                    fila = row_offset + row_idx + 1
                    columna = col_offset + col_idx + 1
                    print(f"   âœ“ Encontrado en fila {fila}, columna {columna}")
                    return (fila, columna)
        
        return (None, None)


def llenar_seccion_live(
    client: GraphServices,
    db: Session,
    client_key: str,
    file_key: str,
    section_key: str,
    datos: Dict[str, Any]
):
    """
    Llena una secciÃ³n simple (key-value) EN VIVO.
    Lee TODA la configuraciÃ³n de la base de datos automÃ¡ticamente.
    
    Args:
        client: Cliente de GraphServices
        db: SesiÃ³n de SQLAlchemy
        client_key: Clave del cliente
        file_key: Clave del archivo
        section_key: Clave de la secciÃ³n
        datos: Diccionario con los datos {campo: valor}
    
    Ejemplo:
        llenar_seccion_live(
            client, db,
            client_key="eunoia",
            file_key="waman_cliente_001",
            section_key="cliente",
            datos={"nombre": "ACME", "rfc": "ACM123"}
        )
    """
    print(f"ğŸ“ Llenando secciÃ³n '{section_key}' en archivo '{file_key}'...")
    
    # 1. Obtener archivo de la DB
    excel_file = db.query(ExcelFiles).filter_by(
        client_key=client_key,
        file_key=file_key,
        is_active=True
    ).first()
    
    if not excel_file:
        raise ValueError(f"Archivo '{file_key}' no encontrado")
    
    # 2. Obtener secciÃ³n de la DB
    section = db.query(ExcelSections).filter_by(
        client_key=client_key,
        template_id=excel_file.template_id,
        section_key=section_key,
        is_active=True
    ).first()
    
    if not section:
        raise ValueError(f"SecciÃ³n '{section_key}' no encontrada")
    
    # 3. Obtener campos de la DB
    fields = db.query(ExcelFields).filter_by(
        section_id=section.id,
        is_active=True
    ).all()
    
    if not fields:
        raise ValueError(f"No hay campos definidos para la secciÃ³n '{section_key}'")
    
    # 4. Construir mapeo de columnas desde la DB
    columnas = {field.field_key: field.column_offset for field in fields}
    
    # 5. Obtener storage de la DB
    storage = db.query(StorageTargets).filter_by(
        id=excel_file.storage_target_id
    ).first()
    
    if not storage:
        raise ValueError("Storage no encontrado")
    
    # 6. Construir file_path desde la DB
    file_path = f"{excel_file.file_folder_path}/{excel_file.file_name}".replace("//", "/")
    
    # 7. Determinar drive_id y target_user_id
    drive_id = None
    target_user_id = None
    if storage.location_type.value.upper() == "drive":
        drive_id = storage.location_identifier
    else:
        target_user_id = storage.location_identifier
    
    # 8. Usar marker_text y sheet_name desde la DB
    marker = section.marker_text
    sheet_name = section.sheet_name
    
    # Buscar marcador
    marker_row, marker_col = buscar_marcador_live(
        client, db, client_key, file_key, section_key
    )
    
    if not marker_row:
        raise ValueError(f"No se encontrÃ³ '{marker}' en el Excel")
    
    # Resolver item_id y worksheet
    item_id, _ = client._resolve_item_id(file_path, target_user_id=target_user_id, drive_id=drive_id)
    sheets, _ = client._resolve_worksheets(item_id=item_id, target_user_id=target_user_id, drive_id=drive_id)
    
    if sheet_name:
        sheet = next((s for s in sheets if s.get("name") == sheet_name), None)
    else:
        sheet = sheets[0]
    
    ws_id = sheet["id"]
    ws_name = sheet["name"]
    
    # Fila destino usando row_offset de la DB
    fila_destino = marker_row + section.row_offset
    
    # Construir URL base
    if drive_id:
        base = f"{client.graph_url}/drives/{drive_id}/items/{item_id}"
    else:
        base = f"{client.graph_url}/users/{target_user_id}/drive/items/{item_id}"
    
    # Escribir cada campo
    print(f"   âœï¸  Escribiendo {len(datos)} campos en fila {fila_destino}...")
    for campo, valor in datos.items():
        if campo not in columnas:
            continue
        
        col_offset = columnas[campo]
        col_destino = marker_col + section.column_offset + col_offset
        col_letter = _col_index_to_letters(col_destino)
        
        # DirecciÃ³n de la celda
        cell_address = f"{ws_name}!{col_letter}{fila_destino}"
        
        # PATCH a la celda
        url = f"{base}/workbook/worksheets/{ws_id}/range(address='{cell_address}')"
        
        try:
            client._request_with_retry(
                "PATCH",
                url,
                expected=(200,),
                headers=client._headers(),
                json={"values": [[valor]]}
            )
            print(f"      âœ“ {campo}: {valor}")
        except Exception as e:
            print(f"      âœ— {campo}: Error - {e}")


def llenar_tabla_live(
    client: GraphServices,
    db: Session,
    client_key: str,
    file_key: str,
    section_key: str,
    datos: List[Dict[str, Any]]
):
    """
    Llena una tabla (mÃºltiples filas) EN VIVO.
    Lee TODA la configuraciÃ³n de la base de datos automÃ¡ticamente.
    
    Args:
        client: Cliente de GraphServices
        db: SesiÃ³n de SQLAlchemy
        client_key: Clave del cliente
        file_key: Clave del archivo
        section_key: Clave de la secciÃ³n (debe tener is_table=True)
        datos: Lista de diccionarios con los datos
    
    Ejemplo:
        llenar_tabla_live(
            client, db,
            client_key="eunoia",
            file_key="waman_cliente_001",
            section_key="seguimiento",
            datos=[
                {"fecha": "2025-01", "medio": "Email", "comentarios": "Contacto"},
                {"fecha": "2025-02", "medio": "TelÃ©fono", "comentarios": "Llamada"}
            ]
        )
    """
    print(f"ğŸ“Š Llenando tabla '{section_key}' en archivo '{file_key}'...")
    
    # 1. Obtener archivo de la DB
    excel_file = db.query(ExcelFiles).filter_by(
        client_key=client_key,
        file_key=file_key,
        is_active=True
    ).first()
    
    if not excel_file:
        raise ValueError(f"Archivo '{file_key}' no encontrado")
    
    # 2. Obtener secciÃ³n de la DB
    section = db.query(ExcelSections).filter_by(
        client_key=client_key,
        template_id=excel_file.template_id,
        section_key=section_key,
        is_active=True
    ).first()
    
    if not section:
        raise ValueError(f"SecciÃ³n '{section_key}' no encontrada")
    
    if not section.is_table:
        raise ValueError(f"La secciÃ³n '{section_key}' no estÃ¡ marcada como tabla")
    
    # 3. Obtener campos de la DB
    fields = db.query(ExcelFields).filter_by(
        section_id=section.id,
        is_active=True
    ).all()
    
    if not fields:
        raise ValueError(f"No hay campos definidos para la secciÃ³n '{section_key}'")
    
    # 4. Construir mapeo de columnas desde la DB
    columnas = {field.field_key: field.column_offset for field in fields}
    
    # 5. Obtener storage de la DB
    storage = db.query(StorageTargets).filter_by(
        id=excel_file.storage_target_id
    ).first()
    
    if not storage:
        raise ValueError("Storage no encontrado")
    
    # 6. Construir file_path desde la DB
    file_path = f"{excel_file.file_folder_path}/{excel_file.file_name}".replace("//", "/")
    
    # 7. Determinar drive_id y target_user_id
    drive_id = None
    target_user_id = None
    if storage.location_type.value.upper() == "drive":
        drive_id = storage.location_identifier
    else:
        target_user_id = storage.location_identifier
    
    # 8. Usar marker_text, sheet_name y merges desde la DB
    marker = section.marker_text
    sheet_name = section.sheet_name
    merges_a_aplicar = section.merge_ranges if section.merge_ranges else None
    
    # Buscar marcador
    marker_row, marker_col = buscar_marcador_live(
        client, db, client_key, file_key, section_key
    )
    
    if not marker_row:
        raise ValueError(f"No se encontrÃ³ '{marker}' en el Excel")
    
    # Resolver item_id y worksheet
    item_id, _ = client._resolve_item_id(file_path, target_user_id=target_user_id, drive_id=drive_id)
    sheets, _ = client._resolve_worksheets(item_id=item_id, target_user_id=target_user_id, drive_id=drive_id)
    
    if sheet_name:
        sheet = next((s for s in sheets if s.get("name") == sheet_name), None)
    else:
        sheet = sheets[0]
    
    ws_id = sheet["id"]
    ws_name = sheet["name"]
    
    # Fila de inicio usando row_offset de la DB
    fila_inicio = marker_row + section.row_offset
    
    # Construir URL base
    if drive_id:
        base = f"{client.graph_url}/drives/{drive_id}/items/{item_id}"
    else:
        base = f"{client.graph_url}/users/{target_user_id}/drive/items/{item_id}"
    
    # Preparar datos en formato de matriz
    num_filas = len(datos)
    num_columnas = len(columnas)
    
    # Crear matriz vacÃ­a
    matriz = [[None] * num_columnas for _ in range(num_filas)]
    
    # Llenar matriz
    for row_idx, fila_datos in enumerate(datos):
        for campo, valor in fila_datos.items():
            if campo in columnas:
                col_offset = columnas[campo]
                matriz[row_idx][col_offset] = valor
    
    # Calcular rango usando column_offset de la DB
    col_inicio_letter = _col_index_to_letters(marker_col + section.column_offset)
    col_fin_letter = _col_index_to_letters(marker_col + section.column_offset + num_columnas - 1)
    fila_fin = fila_inicio + num_filas - 1
    
    range_address = f"{ws_name}!{col_inicio_letter}{fila_inicio}:{col_fin_letter}{fila_fin}"
    
    # PATCH al rango completo
    url = f"{base}/workbook/worksheets/{ws_id}/range(address='{range_address}')"
    
    print(f"   âœï¸  Escribiendo {num_filas} filas en rango {range_address}...")
    
    try:
        client._request_with_retry(
            "PATCH",
            url,
            expected=(200,),
            headers=client._headers(),
            json={"values": matriz}
        )
        print(f"      âœ“ {num_filas} filas escritas exitosamente")
    except Exception as e:
        print(f"      âœ— Error: {e}")
    
    # Aplicar merges si se especificaron
    if merges_a_aplicar and len(merges_a_aplicar) > 0:
        try:
            print(f"      ğŸ’¡ Aplicando merges a {num_filas} filas...")
            
            for i in range(num_filas):
                fila_actual = fila_inicio + i
                
                for merge_range in merges_a_aplicar:
                    if ":" in merge_range:
                        col_inicio_merge, col_fin_merge = merge_range.split(":")
                        # Ajustar al offset del marcador
                        col_inicio_abs = col_inicio_merge
                        col_fin_abs = col_fin_merge
                        rango_merge = f"{col_inicio_abs}{fila_actual}:{col_fin_abs}{fila_actual}"
                    else:
                        continue
                    
                    merge_url = f"{base}/workbook/worksheets/{ws_id}/range(address='{rango_merge}')/merge"
                    try:
                        client._request_with_retry(
                            "POST",
                            merge_url,
                            expected=(200, 204),
                            headers=client._headers(),
                            json={"across": True}
                        )
                    except Exception as e_merge:
                        print(f"      âš ï¸  No se pudo mergear {rango_merge}: {e_merge}")
            
            print(f"      âœ“ Merges aplicados")
        except Exception as e_merges:
            print(f"      âš ï¸  Error aplicando merges: {e_merges}")


def procesar_excel_live(
    client: GraphServices,
    db: Session,
    client_key: str,
    file_key: str,
    secciones: Dict[str, Any]
):
    """
    FunciÃ³n todo-en-uno para procesar mÃºltiples secciones EN VIVO.
    Lee TODA la configuraciÃ³n de la base de datos automÃ¡ticamente.
    
    Args:
        client: Cliente de GraphServices
        db: SesiÃ³n de SQLAlchemy
        client_key: Clave del cliente
        file_key: Clave del archivo
        secciones: Datos por secciÃ³n {"section_key": datos}
    
    Ejemplo:
        procesar_excel_live(
            client, db,
            client_key="eunoia",
            file_key="waman_cliente_001",
            secciones={
                "cliente": {"nombre": "ACME", "rfc": "ACM123"},
                "seguimiento": [{"fecha": "2025-01", "medio": "Email"}]
            }
        )
    """
    print("ğŸ”¥ Procesando Excel EN VIVO...")
    
    # 1. Obtener archivo de la DB
    excel_file = db.query(ExcelFiles).filter_by(
        client_key=client_key,
        file_key=file_key,
        is_active=True
    ).first()
    
    if not excel_file:
        raise ValueError(f"Archivo '{file_key}' no encontrado")
    
    # 2. Procesar cada secciÃ³n
    for section_key, datos in secciones.items():
        print(f"\nğŸ“ SecciÃ³n: {section_key}")
        
        # Obtener secciÃ³n de la DB
        section = db.query(ExcelSections).filter_by(
            client_key=client_key,
            template_id=excel_file.template_id,
            section_key=section_key,
            is_active=True
        ).first()
        
        if not section:
            print(f"   âš ï¸  SecciÃ³n '{section_key}' no encontrada - saltando")
            continue
        
        # Determinar si es tabla o secciÃ³n simple
        if section.is_table:
            llenar_tabla_live(
                client, db, client_key, file_key, section_key, datos
            )
        else:
            llenar_seccion_live(
                client, db, client_key, file_key, section_key, datos
            )
    
    print("\nâœ… Proceso completado")


def obtener_merges_fila(
    client: GraphServices,
    item_id: str,
    ws_id: str,
    fila: int,
    target_user_id: str = None,
    drive_id: str = None
) -> List[Dict[str, Any]]:
    """
    Obtiene los rangos merged de una fila especÃ­fica.
    
    Args:
        client: Cliente de GraphServices
        item_id: ID del archivo
        ws_id: ID de la hoja
        fila: NÃºmero de fila (1-indexed)
        target_user_id: Email del usuario
        drive_id: ID del drive
    
    Returns:
        Lista de rangos merged que incluyen esa fila
        Ejemplo: [{"address": "A22:C22"}, {"address": "D22:F22"}]
    """
    if drive_id:
        base = f"{client.graph_url}/drives/{drive_id}/items/{item_id}"
    else:
        base = f"{client.graph_url}/users/{target_user_id}/drive/items/{item_id}"
    
    # Obtener el rango usado de la hoja
    url = f"{base}/workbook/worksheets/{ws_id}/usedRange"
    resp, _ = client._request_with_retry("GET", url, expected=(200,), headers=client._headers())
    data = resp.json()
    
    # Obtener merged cells de la hoja
    # Microsoft Graph no tiene endpoint directo, asÃ­ que usamos range/format
    # Obtenemos el formato del rango de la fila
    col_start = data.get("columnIndex", 0) + 1
    col_end = data.get("columnIndex", 0) + data.get("columnCount", 10)
    
    col_start_letter = _col_index_to_letters(col_start)
    col_end_letter = _col_index_to_letters(col_end)
    
    range_address = f"{col_start_letter}{fila}:{col_end_letter}{fila}"
    
    url = f"{base}/workbook/worksheets/{ws_id}/range(address='{range_address}')"
    resp, _ = client._request_with_retry("GET", url, expected=(200,), headers=client._headers())
    data = resp.json()
    
    merges = []
    cell_count = data.get("cellCount", 0)
    row_count = data.get("rowCount", 1)
    col_count = data.get("columnCount", 0)
    
    # Si el rango tiene merges, los extraemos manualmente
    # Verificando el nÃºmero de celdas vs el tamaÃ±o esperado
    if "address" in data:
        # Para detectar merges, necesitamos verificar cada celda
        # Usamos la propiedad mergedAreas si estÃ¡ disponible
        address = data.get("address", "")
        if "!" in address:
            address = address.split("!")[-1]
        
        # Por ahora, retornamos info bÃ¡sica
        # En una implementaciÃ³n mÃ¡s completa, iterarÃ­amos celda por celda
        merges.append({"address": address, "row": fila})
    
    return merges


def aplicar_merges_filas(
    client: GraphServices,
    item_id: str,
    ws_id: str,
    ws_name: str,
    fila_template: int,
    filas_destino: List[int],
    target_user_id: str = None,
    drive_id: str = None
):
    """
    Aplica los merges de una fila template a mÃºltiples filas destino.
    
    Args:
        client: Cliente de GraphServices
        item_id: ID del archivo
        ws_id: ID de la hoja
        ws_name: Nombre de la hoja
        fila_template: Fila de la cual copiar el formato de merge
        filas_destino: Lista de filas donde aplicar los merges
        target_user_id: Email del usuario
        drive_id: ID del drive
    """
    if drive_id:
        base = f"{client.graph_url}/drives/{drive_id}/items/{item_id}"
    else:
        base = f"{client.graph_url}/users/{target_user_id}/drive/items/{item_id}"
    
    # Obtener el rango de la fila template para analizar sus merges
    url = f"{base}/workbook/worksheets/{ws_id}/range(address='{fila_template}:{fila_template}')"
    resp, _ = client._request_with_retry("GET", url, expected=(200,), headers=client._headers())
    template_data = resp.json()
    
    # Obtener el formato completo incluyendo merges
    format_url = f"{base}/workbook/worksheets/{ws_id}/range(address='{fila_template}:{fila_template}')/format"
    resp_format, _ = client._request_with_retry("GET", format_url, expected=(200,), headers=client._headers())
    format_data = resp_format.json()
    
    # Detectar rangos merged analizando el formato de celdas
    # Microsoft Graph API tiene limitaciones aquÃ­, usaremos merge directo por rango
    # Aplicar merge a las filas destino con el mismo patrÃ³n
    
    for fila_dest in filas_destino:
        # Intentar copiar el formato completo de la fila template
        try:
            # Merge especÃ­fico: necesitamos saber quÃ© columnas estÃ¡n merged
            # Por ahora, aplicaremos merge basado en el patrÃ³n mÃ¡s comÃºn
            # que vemos en la imagen: A-C merged
            
            # OpciÃ³n simple: merge las mismas columnas que en template
            col_start_letter = template_data.get("address", "A1").split("!")[0] if "!" in template_data.get("address", "") else "A"
            
            # Para cada rango merged detectado, aplicarlo a la fila destino
            # Esto es una aproximaciÃ³n - idealmente necesitarÃ­amos la API de MergedAreas
            pass
            
        except Exception as e:
            print(f"      âš ï¸  Error copiando formato de fila {fila_template} a {fila_dest}: {e}")


def insertar_filas_live(
    client: GraphServices,
    db: Session,
    client_key: str,
    file_key: str,
    section_key: str,
    fila_inicio: int,
    datos: List[Dict[str, Any]]
):
    """
    Inserta filas nuevas en una posiciÃ³n especÃ­fica EN VIVO.
    Lee TODA la configuraciÃ³n de la base de datos automÃ¡ticamente.
    
    Esta funciÃ³n inserta filas completas moviendo las existentes hacia abajo,
    llena las nuevas filas con los datos proporcionados, y opcionalmente
    aplica merges de celdas para mantener el formato de la tabla.
    
    Args:
        client: Cliente de GraphServices
        db: SesiÃ³n de SQLAlchemy
        client_key: Clave del cliente
        file_key: Clave del archivo
        section_key: Clave de la secciÃ³n
        fila_inicio: NÃºmero de fila donde insertar (1-indexed)
        datos: Lista de diccionarios con los datos
    
    Ejemplo:
        insertar_filas_live(
            client, db,
            client_key="eunoia",
            file_key="waman_cliente_001",
            section_key="seguimiento",
            fila_inicio=25,
            datos=[
                {"fecha": "2025-01", "medio": "Email", "comentarios": "Nuevo"},
                {"fecha": "2025-02", "medio": "Tel", "comentarios": "Otro"}
            ]
        )
    """
    print(f"â• Insertando filas en secciÃ³n '{section_key}' del archivo '{file_key}'...")
    
    # 1. Obtener archivo de la DB
    excel_file = db.query(ExcelFiles).filter_by(
        client_key=client_key,
        file_key=file_key,
        is_active=True
    ).first()
    
    if not excel_file:
        raise ValueError(f"Archivo '{file_key}' no encontrado")
    
    # 2. Obtener secciÃ³n de la DB
    section = db.query(ExcelSections).filter_by(
        client_key=client_key,
        template_id=excel_file.template_id,
        section_key=section_key,
        is_active=True
    ).first()
    
    if not section:
        raise ValueError(f"SecciÃ³n '{section_key}' no encontrada")
    
    # 3. Obtener campos de la DB
    fields = db.query(ExcelFields).filter_by(
        section_id=section.id,
        is_active=True
    ).all()
    
    if not fields:
        raise ValueError(f"No hay campos definidos para la secciÃ³n '{section_key}'")
    
    # 4. Construir mapeo de columnas desde la DB
    columnas = {field.field_key: field.column_offset for field in fields}
    
    # 5. Obtener storage de la DB
    storage = db.query(StorageTargets).filter_by(
        id=excel_file.storage_target_id
    ).first()
    
    if not storage:
        raise ValueError("Storage no encontrado")
    
    # 6. Construir file_path desde la DB
    file_path = f"{excel_file.file_folder_path}/{excel_file.file_name}".replace("//", "/")
    
    # 7. Determinar drive_id y target_user_id
    drive_id = None
    target_user_id = None
    if storage.location_type.value.upper() == "drive":
        drive_id = storage.location_identifier
    else:
        target_user_id = storage.location_identifier
    
    # 8. Usar sheet_name, column_offset y merges desde la DB
    sheet_name = section.sheet_name
    columna_inicio = section.column_offset + 1
    merges_a_aplicar = section.merge_ranges if section.merge_ranges else None
    
    # Resolver item_id y worksheet
    item_id, _ = client._resolve_item_id(file_path, target_user_id=target_user_id, drive_id=drive_id)
    sheets, _ = client._resolve_worksheets(item_id=item_id, target_user_id=target_user_id, drive_id=drive_id)
    
    if sheet_name:
        sheet = next((s for s in sheets if s.get("name") == sheet_name), None)
        if not sheet:
            raise ValueError(f"Hoja '{sheet_name}' no encontrada")
    else:
        sheet = sheets[0]
    
    ws_id = sheet["id"]
    ws_name = sheet["name"]
    
    # Construir URL base
    if drive_id:
        base = f"{client.graph_url}/drives/{drive_id}/items/{item_id}"
    else:
        base = f"{client.graph_url}/users/{target_user_id}/drive/items/{item_id}"
    
    num_filas = len(datos)
    num_columnas = len(columnas)
    
    # Preparar matriz de datos
    matriz = [[None] * num_columnas for _ in range(num_filas)]
    
    for row_idx, fila_datos in enumerate(datos):
        for campo, valor in fila_datos.items():
            if campo in columnas:
                col_offset = columnas[campo]
                matriz[row_idx][col_offset] = valor
    
    # Calcular rango
    col_inicio_letter = _col_index_to_letters(columna_inicio)
    col_fin_letter = _col_index_to_letters(columna_inicio + num_columnas - 1)
    fila_fin = fila_inicio + num_filas - 1
    
    # Usar direcciÃ³n simple sin nombre de hoja para el insert
    range_simple = f"{col_inicio_letter}{fila_inicio}:{col_fin_letter}{fila_fin}"
    range_con_hoja = f"{ws_name}!{range_simple}"
    
    print(f"   ğŸ“ Insertando {num_filas} filas en {range_con_hoja}...")
    
    # PASO 1: Insertar filas usando el endpoint de filas completas
    inserted = False
    
    try:
        # Insertar filas completas una por una desde la posiciÃ³n especificada
        print(f"      ğŸ’¡ Insertando {num_filas} filas completas...")
        for i in range(num_filas):
            # La fila actual donde insertar (siempre es fila_inicio porque cada insert mueve las siguientes)
            row_range = f"{fila_inicio}:{fila_inicio}"
            insert_url = f"{base}/workbook/worksheets/{ws_id}/range(address='{row_range}')/insert"
            
            client._request_with_retry(
                "POST",
                insert_url,
                expected=(200, 201),
                headers=client._headers(),
                json={"shift": "Down"}
            )
        print(f"      âœ“ {num_filas} filas insertadas correctamente")
        inserted = True
    except Exception as e1:
        print(f"      âœ— Error insertando filas completas: {e1}")
    
    # Si la inserciÃ³n fallÃ³, usar escritura directa
    if not inserted:
        print(f"      ğŸ’¡ Usando escritura directa (sobrescribe celdas existentes)...")
        try:
            url = f"{base}/workbook/worksheets/{ws_id}/range(address='{range_simple}')"
            client._request_with_retry(
                "PATCH",
                url,
                expected=(200,),
                headers=client._headers(),
                json={"values": matriz}
            )
            print(f"      âœ“ Datos escritos directamente (sin insertar)")
            return  # Salir porque ya terminamos
        except Exception as e3:
            print(f"      âœ— Error con escritura directa: {e3}")
            raise Exception("No se pudo insertar ni escribir las filas")
    
    # PASO 2: Llenar las filas insertadas con datos
    url = f"{base}/workbook/worksheets/{ws_id}/range(address='{range_simple}')"
    
    try:
        client._request_with_retry(
            "PATCH",
            url,
            expected=(200,),
            headers=client._headers(),
            json={"values": matriz}
        )
        print(f"      âœ“ Datos escritos en {num_filas} filas")
    except Exception as e:
        print(f"      âœ— Error escribiendo datos: {e}")
        raise
    
    # PASO 3: Aplicar merges si se especificaron
    if merges_a_aplicar and len(merges_a_aplicar) > 0:
        try:
            print(f"      ğŸ’¡ Aplicando merges a {num_filas} filas...")
            
            for i in range(num_filas):
                fila_actual = fila_inicio + i
                
                for merge_range in merges_a_aplicar:
                    # El rango puede ser "A:C" o letras de columna
                    # Lo convertimos a un rango completo con la fila actual
                    if ":" in merge_range:
                        col_inicio_merge, col_fin_merge = merge_range.split(":")
                        rango_merge = f"{col_inicio_merge}{fila_actual}:{col_fin_merge}{fila_actual}"
                    else:
                        # Si solo es una columna, no hacer merge
                        continue
                    
                    # Aplicar merge
                    merge_url = f"{base}/workbook/worksheets/{ws_id}/range(address='{rango_merge}')/merge"
                    try:
                        client._request_with_retry(
                            "POST",
                            merge_url,
                            expected=(200, 204),
                            headers=client._headers(),
                            json={"across": True}  # Merge horizontal
                        )
                    except Exception as e_merge:
                        print(f"      âš ï¸  No se pudo mergear {rango_merge}: {e_merge}")
            
            print(f"      âœ“ Merges aplicados correctamente")
        except Exception as e_merges:
            print(f"      âš ï¸  Error aplicando merges: {e_merges}")


# =============================================================================
# FUNCIONES CON CONFIGURACIÃ“N DE BASE DE DATOS
# =============================================================================

def copy_template_live(
    client: GraphServices,
    db: Session,
    client_key: str,
    template_key: str,
    dest_file_name: str
) -> Tuple[str, str]:
    """
    Copia un template de Excel sin llenarlo.
    Lee TODA la configuraciÃ³n de la base de datos automÃ¡ticamente.
    
    Args:
        client: Cliente de GraphServices
        db: SesiÃ³n de SQLAlchemy
        client_key: Clave del cliente en tenant_credentials
        template_key: Clave del template en templates
        dest_file_name: Nombre del archivo de destino
    
    Returns:
        Tupla (item_id, web_url) del archivo copiado
    
    Ejemplo:
        item_id, url = copy_template_live(
            client, db,
            client_key="eunoia",
            template_key="waman_prueba",
            dest_file_name="Nuevo_Cliente_2025.xlsx"
        )
    """
    print(f"ğŸ“‹ Copiando template '{template_key}' para cliente '{client_key}'...")
    
    # 1. Obtener configuraciÃ³n del cliente
    creds = db.query(TenantCredentials).filter_by(
        client_key=client_key,
        enabled=True
    ).first()
    
    if not creds:
        raise ValueError(f"Cliente '{client_key}' no encontrado o deshabilitado")
    
    # 2. Obtener configuraciÃ³n del template
    template = db.query(Templates).filter_by(
        client_key=client_key,
        template_key=template_key,
        is_active=True
    ).first()
    
    if not template:
        raise ValueError(f"Template '{template_key}' no encontrado o inactivo")
    
    # 3. Obtener configuraciÃ³n de storage (primer storage disponible)
    storage = db.query(StorageTargets).filter_by(
        client_key=client_key,
        tenant_id=creds.id
    ).first()
    
    if not storage:
        raise ValueError("No se encontrÃ³ configuraciÃ³n de storage")
    
    # 4. Construir rutas desde la DB
    def _join_path(*parts):
        return "/".join(p.strip("/") for p in parts if p)
    
    template_path = _join_path(template.template_folder_path, template.template_file_name)
    dest_path = _join_path(storage.default_dest_folder_path, dest_file_name)
    
    # 5. Determinar target desde storage
    drive_id = None
    target_user_id = None
    
    if storage.location_type.value.upper() == "drive":
        drive_id = storage.location_identifier
    else:
        target_user_id = storage.location_identifier
    
    print(f"   ğŸ“‚ Template: {template_path}")
    print(f"   ğŸ“ Destino: {dest_path}")
    print(f"   ğŸ¯ Target: {'drive=' + drive_id if drive_id else 'user=' + target_user_id}")
    
    # 6. Descargar template
    print(f"   â¬‡ï¸  Descargando template...")
    template_bytes, _ = client.download_file_bytes(
        template_path,
        target_user_id=target_user_id,
        drive_id=drive_id
    )
    
    # 7. Obtener conflict_behavior de la DB (o usar default)
    conflict_behavior = getattr(template, 'default_conflict_behavior', 'rename') or 'rename'
    
    # 8. Subir al destino
    print(f"   â¬†ï¸  Copiando a destino (conflict: {conflict_behavior})...")
    result, _ = client.upload_file_bytes(
        template_bytes,
        dest_path,
        conflict_behavior=conflict_behavior,
        target_user_id=target_user_id,
        drive_id=drive_id
    )
    
    item_id = result.get("id")
    web_url = result.get("webUrl")
    
    print(f"   âœ… Archivo copiado exitosamente")
    print(f"      ID: {item_id}")
    print(f"      URL: {web_url}")
    
    return item_id, web_url
